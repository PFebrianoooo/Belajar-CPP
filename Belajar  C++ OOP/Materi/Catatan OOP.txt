// OOP -1 starts //
Pendahuluan

Object oriented programming
apa itu object oriented programming ?

object oriented adalah sebuah metode dimana mengelompokan objek kedalam suatu kelas.

dimana object oriented programming berfunhgsi uuntuk membuat program yang lebih kompleks dnegan menggabungkan variable variable fungsi fungsi data data kedalam satu loyang yang disebut dengan kelas.

class Mahasiswa {
	string Nama;
	string Nim;
	string jurusan;

	void RubahNama(){
	}
}

jadi intinya object oriented programming adalah sebuah method untuk menggabungkan semua data-data , fungsi-fungsi kedalam suatu tipe yang dinamakan dengan kelas.

apabila di c++ dasar kita menggunakan basic program struktural, sedangkan di OOP kita menggunakan object atau pengelompokan kedalm suatu loyang yang dinamakan dengan class

// OOP -1 ends //

// OOP -2 starts //
setup windows menggunakan visual studio code

step by step
1. membuat folder utama dan diisi oleh 2 folder untuk source code dan hasil compilenya.
2. membuat file bebas namanya dengan extension file .cpp ditaruh di file source code.
3. setup visual studio code menggunakan c\c++ edit configuration json dengan ctrl+shift+p lalu save
3. setup visual studio code dengan membuat folder tasks.json di file vs code dan mensetup file mulai dari compile sampai run c++
4. menulis code di file source code dan click ctrl+shift+p untuk mengcompile file dan mendapatkan hasil berupa file compile nya

setelah mengikuti langkah-langkah harusnya visual studio code sudah bisa di jalankan untuk menulis code c++

// OOP -2 ends //

// OOP -3 starts //
Pengenalan Kelas Dan Object

init
class Mahasiswa {
	public:
		string nama;      // data member
		string jurusan;
		string nilai;
	private:
		string ipk;
		char grade;
	protected:

}

class adalah loyang atau template dimana dapat menyimpan berupa 
1. data member atau attribute atau data
2. member function atau method atau fungsi


pengaksesan kelas / access modifier:
1. Public
2. Privat
3. Protected


1. Public 
dapat diakses oleh siapapun diluar kelas 
2. privat 
hanya dapat diakses oleh didalam kelas
3. protected
hanya dapat diakses oleh kelas me deirved class ini

// OOP -3 ends //

// OOP -4 starts //
constructor.

fungsi yang pertama kali diakses oleh objek dan biasanya constructor digunakan untuk menginialisasi sebuha variable public, private dan protected.

initialisation

class Mahasiswa {

public :
	string Nama;
	string Nim;

		
	// constructor
Mahasiswa (string Nama, string Nim){
	Mahasiswa::Nama = Nama;
	Mahasiswa::Nim = Nim;

	cout << Nama << endl;
	cout << Nim << endl;


	}


};

constructor biasanya digunakan untuk
1. tempat inisialisasi data member.

// OOP -4 ends //

// OOP -5 starts //
Member function atau method

member function atau method berisi fungsi-fungsi untuk mengoperasikan objek sesuai yang dimau oleh user. biasanya berisi fungsi-fungsi untuk CRUD pada objek

method dibagi menjadi 4
1. Tanpa Parameter dan tanpa return.
2. Dengan parameter tanpa return.
3. Tanpa parameter dengan return.
4. dengan parameter dan return


> 1. Tanpa Parameter dan tanpa return.
biasanya hanya mendisplaykan saja 

void TampilData(){
	cout << Mahasiswa::Nama << endl;
	cout << Mahasiswa::Nim << endl;
	cout << Mahasiswa::Jurusan << endl;
}

> 2. Dengan parameter tanpa return
void UbahData (const char* Nama, const double Ipk){
mahasiswa::Nama = Nama;
Mahasiswa::Ipk = Ipk;
}

> 3. Tanpa parameter dengan return
string AmbilNama (){
return Mahasiswa::nama;
}

> 4. Dengan Parameter dan return
biasanya menggunakan operator
string (const char* &Nlai, const char* Nim){
return mahasiswa::nim + Nim;
return Mahasiswa::Nilai + Nlai;
}

// OOP -5 ends //

// OOP -6 starts //
latihan membuat Dbase dengan konsep create dan read.

// OOP -6 ends //

// OOP -7 starts //
berbagai cara menulis class dan alokasi memory

memory pada c++ dibagi menjadi 2 
1. heap memory
2. stack memory

1. pada heap memory perlu pointer untuk mengaksesnya
2. pada stack emory tidak perlu pointer untuk mengaksesnya

4 cara menulis dengan class
selengkapnya pada syntax

// OOP -7 ends //

// OOP -8 starts //
Memory dan adress dari object

Memory 
memory dari sebuah kelas tergantung daripada ukuran dari data membernya atau atribute yang di deklarasikan didalam kelas mengecualikan semua fungsi yang di deklarasikan di bawahnya.

dibagi menjadi 2 
1. Stack Memory
2. Heap Memory

1. stack memory
Apabila di deklarasika 5 tipe data makan penempatan tipe data yang pertama paling bawah sesuai dengan struktur data dan algoritma dengan prinsip LIFO. apabila di deklarasikan fungsi maka mengisi alokasi memory setelahnya dan ssetiap selesai maka meory nya akan di release atau di hapus.

Stack memory itu terbatas

2. Heap Memory
Heap Memory Atau Disebut dengan free memory.

untuk menulis memory ke heap menggunakan keyword new.

// OOP -8 ends //

// OOP -9 starts //
Destructor and object lifetime

destructor adalah saat mwnjalankan fungsi constructor selesai maka menjalankan fungsi destructor untuk menghapus runag di memory agar tidak terjadi memory leak

destructoor adalah sebuah fungsi yang digunakan untuk mengahpus ruang di memory dimanaa dalam peng aksesannya menggunakan pinter secara langsung

intitialisation

~classname(){
// args

}

contoh kasus

player *Object1;
Object1 = new player("andi");
delete Object1;

contoh diatas merupakan cara menghapus alokasi memory dengan menngunakan perintah delete.

// OOP -9 ends //

// OOP -10 starts //
Namespace vs this

nameespace digunakan untuk pemberian refers kepada prototype fungsi sedangkan this digunakan untuk pemeberian refers kepada kelas.

contoh
class Mahasiswa {
	public :
	string nama;
	string nim;
	string nilai;

	Mahasiswa(const char * nama, const char * nim , const char * nilai){
		this->nama = nama;
		thid->nim = nim;
		this->nilai = nilai;
		
};

namesapce ruangan {
	class Mahasiswa 
	{
		public :
		string nilai ;
		string nim;
		string nama;
		
		Mahasiswa(const char *nilai , const char *nim , const char *nama)
			{
			this->nilai = nilai;
			this->nim = nim;
			this->nama = nama;
			}	

		void TampilNama()
			{
			cout << this->nim << endl;
			cout << this->nama << endl;
			cout << this->nilai << endl;
			}
		string GetNama (const char* nama)
			{
			return this->nama;
			}				
        };
	


};


main (){

	
	Mahasiswa* Object1;
	Object1 = new Mahasiswa("otong","2204070039","90");
	cout << Object1->nama << endl;
	cout << Object1->nim << endl;
	cout << Object->nilai << endl;

Ruangan::Mahasiswa* Object2;
	Object2 = new Ruangan::Mahasiswa("otong","2204070039","90");
	Object->TampilNama();
}

arrow function digunakan sebagai pengganti :: pada namespace atau object dan this digunakan untuk merefers kelas

// OOP -10 ends //

// OOP -11 starts //
prototype fungsi.

prototype fungsi adalah penjabaran dari method atau member function dengan menjabarkan isi dari method i bawah atau di file header untuk mempersingkat syntax pada source code main

prototype fungsi di OOP hammpir sama dengan prototype pada C++ Dasar perbedaanya adalah harus me reversing class yang mau di prototype-kan fungsinya.

Contoh Penggunaan 

class Mahasiswa {
	public :
	string nama;
	string nim;
	string nilai;

	Mahasiswa(const char * nama, const char * nim , const char * nilai){
		this->nama = nama;
		thid->nim = nim;
		this->nilai = nilai;

	void TampilData();
	string GetNama(const char *nama);
};


// prototype fungsinya

void Mahasiswa::TampilData()
		{
		cout << this->nim << endl;
		cout << this->nama << endl;
		cout << this->nilai << endl;
		}
string Mahasiswa::GetNama(const char * nama)
		{
		return this->nama ;
		}

// OOP -11 ends //
// OOP -12 starts // 
multifile programs

sama halnya dengan multifile pada c++ dasar tetapi patut di perhatikan
1. penulisan include pada file dengan #include "nama header"

2. tasks.json
hampir sama pada tasks.json sebelummnya tetapi di multifile perlu adanya compile per file apabila file c++ dan meng combine stiap file yang di compile per file dan menggabngkannya

"label" : "compile an every file",
"type" : "shell",
"command" : "g++",
"args" : [
"-std=c++17",
"${file}",
"-c",
"-o",
".\\nama file objek\\${fileBasenameNoExtension}.o"

"label" : "combine all file",
"type" : "shell",
"command" : "g++",
"args" : [
"-std=c++17",
".\\nama file objeck\*.o",
"-o",
".\\nama file objek\\main.exe"

"label" : "compile an every file",
"type" : "shell",
"command" : ".\\fileobjek\\main.exe",
"depends-on" : ["combine all file"]
"group":[
"kind" :"build",
"is-default": true
]


3. penulisan preprocessing directive dengan 
ifndef __PLAYER
#define __PLAYER
endif
sebagai guard untuk tidak di deefiisikan secara berulang lagi

// OOP -12 Ends //

// OOP -13 starts //
// OOP -13 ends //